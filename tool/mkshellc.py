#!/usr/bin/env python3
"""
Python replacement for mkshellc.tcl

Run this script to generate the "shell.c" source file from constituent parts.

No arguments are required.  This script determines the location of its input
files relative to the location of the script itself.  This script should be
tool/mkshellc.py.  If the directory holding the script is $DIR, then the
component parts are located in $DIR/../src and $DIR/../ext/misc.

Example usage:
  python3 mkshellc.py [output_file]
"""

import os
import sys
import re
from pathlib import Path


def omit_redundant_typedefs(line, typedef_seen):
    """Remove redundant typedef declarations"""
    typedef_match = re.match(r'^typedef .* ([a-zA-Z0-9_]+);', line)
    if typedef_match:
        typename = typedef_match.group(1)
        if typename in typedef_seen:
            return f"/* {line.replace('/*', '//').replace('*/', '//')} */"
        typedef_seen[typename] = True
    return line


def process_shell_c_in(top_dir, output_file):
    """Process shell.c.in and generate shell.c"""
    shell_c_in = top_dir / 'src' / 'shell.c.in'

    if not shell_c_in.exists():
        print(f"Error: {shell_c_in} not found", file=sys.stderr)
        sys.exit(1)

    # Write header comment
    output_file.write("""/* DO NOT EDIT!
** This file is automatically generated by the script in the canonical
** SQLite source tree at tool/mkshellc.py.  That script combines source
** code from various constituent source files of SQLite into this single
** "shell.c" file used to implement the SQLite command-line shell.
**
** Most of the code found below comes from the "src/shell.c.in" file in
** the canonical SQLite source tree.  That main file contains "INCLUDE"
** lines that specify other files in the canonical source tree that are
** inserted to generate this complete program source file.
**
** The code from multiple files is combined into this single "shell.c"
** source file to help make the command-line program easier to compile.
**
** To modify this program, get a copy of the canonical SQLite source tree,
** edit the src/shell.c.in" and/or some of the other files that are included
** by "src/shell.c.in", then rerun the tool/mkshellc.py script.
*/
""")

    typedef_seen = {}
    line_number = 0

    with open(shell_c_in, 'r', encoding='utf-8') as f:
        for line in f:
            line_number += 1
            line = line.rstrip('\r\n')

            # Process INCLUDE directives
            include_match = re.match(r'^INCLUDE\s+(.+)$', line)
            if include_match:
                include_file = include_match.group(1).strip()
                include_path = top_dir / 'src' / include_file

                output_file.write(f"/************************* Begin {include_file} ******************/\n")

                if include_path.exists():
                    with open(include_path, 'r', encoding='utf-8') as include_f:
                        for include_line in include_f:
                            include_line = include_line.rstrip('\r\n')
                            include_line = omit_redundant_typedefs(include_line, typedef_seen)

                            # Comment out sqlite3.h includes
                            if re.match(r'^#\s*include\s+"sqlite', include_line):
                                include_line = f"/* {include_line} */"

                            # Comment out test_windirent.h includes
                            if re.match(r'^#\s*include\s+"test_windirent.h"', include_line):
                                include_line = f"/* {include_line} */"

                            # Remove __declspec(dllexport)
                            include_line = include_line.replace('__declspec(dllexport)', '')

                            output_file.write(include_line + '\n')
                else:
                    print(f"Warning: Include file {include_path} not found", file=sys.stderr)

                output_file.write(f"/************************* End {include_file} ********************/\n")
                continue

            # Process regular lines
            line = omit_redundant_typedefs(line, typedef_seen)
            output_file.write(line + '\n')


def main():
    # Determine script location and top directory
    script_path = Path(__file__).resolve()
    tool_dir = script_path.parent
    top_dir = tool_dir.parent

    # Determine output file
    if len(sys.argv) > 1:
        output_path = Path(sys.argv[1])
        output_file = open(output_path, 'w', encoding='utf-8')
    else:
        output_file = sys.stdout

    try:
        process_shell_c_in(top_dir, output_file)
    finally:
        if output_file != sys.stdout:
            output_file.close()


if __name__ == '__main__':
    main()